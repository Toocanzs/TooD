Texture2D<float4> WallBuffer;
RWTexture2D<float4> IrradianceBuffer;
RWTexture2D<float4> AverageIrradianceBuffer;
float probeSeparation;
float2 probeStartPosition;//GetProbeAreaOrigin() + OriginOffset
int directionCount;
int maxRayLength;
uint2 wallBufferSize;
uint2 probeCount;
int gutterSize;
float2 _ProbeAreaOrigin;
float HYSTERESIS;
int pixelsPerUnit;
float randomRayOffset;

float4x4 worldToWallBuffer;
float4x4 worldDirectionToBufferDirection;

#define MAX_DIRECTION_COUNT 128
#define PI 3.14159

struct RaycastResult
{
    float3 color;
    float2 endPosition;
    bool hit;
};

RaycastResult raycast(float2 start, float2 dir) 
{
    
    RaycastResult result;
    result.color = 0;
    result.endPosition = start;
    result.hit = false;
    dir /= max(abs(dir.x), abs(dir.y));
    float2 xy = 0;
    for(int i = 0; i < maxRayLength; i++)
    {
        float2 pos = start + xy;
        if(any(bool4(pos.xy < 0, pos.xy >= float2(wallBufferSize))))
        {
            return result;
        }
        float4 color = WallBuffer[int2(pos)];
        if(color.a > 0)
        {
            result.color = color.rgb;
            result.hit = true;
            return result;
        }
        xy += dir;
        result.endPosition = int2(pos);
    }
    return result;
}

struct PixelGroup
{
    uint2 BL;
    uint2 BR;
    uint2 TL;
    uint2 TR;
};

float map(PixelGroup pixels, float2 p)
{
    float bottom = lerp(WallBuffer[pixels.BL].a, WallBuffer[pixels.BR].a, p.x);
    float top = lerp(WallBuffer[pixels.TL].a, WallBuffer[pixels.TR].a, p.x);
    return lerp(bottom, top, p.y);
}

float2 get2DNormal(PixelGroup pixels) 
{
    float EPSILON = 0.25;
    return normalize(float2(
        map(pixels, float2(EPSILON, 0)) - map(pixels, float2(-EPSILON, 0)),
        map(pixels, float2(0, EPSILON)) - map(pixels, float2(0, -EPSILON))
    ));
    //TODO: maybe sample 8 directions since we're not using an sdf anymore
}

float4 sampleIrradianceDirection(float2 normal, uint2 probe)
{
    float angle = atan2(normal.y, normal.x);
    int directionIndex = (angle /(2*PI))*directionCount;
    uint2 st = (probe) * uint2(directionCount + gutterSize * 2, 1);
    uint2 directionUV = st + uint2(gutterSize + directionIndex, 0);
    //TODO: needs to get rid of data that is inside walls or not visible from the probe?
    return IrradianceBuffer[directionUV];
}

#pragma kernel GenerateProbeData
[numthreads(64,1,1)]
void GenerateProbeData (uint3 groupID : SV_GroupID, 
   uint3 groupThreadID : SV_GroupThreadID, 
   uint groupIndex : SV_GroupIndex, 
   uint3 id : SV_DispatchThreadID) 
{
    float2 rayOriginWS = probeStartPosition + float2(id.xy) * probeSeparation;
    float3 directionColors[MAX_DIRECTION_COUNT];
    uint2 rowStartPos = id.xy * uint2(directionCount + gutterSize * 2, 1);
    
    for(int l = 0; l < directionCount; l++)
    {
        directionColors[l] = 0;//May or may not need to initialize
    }
    
    float denominator = (0.5/directionCount);
    //only half the rays contribute to a particular direction, so average acoss all those is sum/directionCount/2
    for(int i = 0; i < directionCount; i++)
    {
        float percent = float(i)/float(directionCount);
        float angle = 2*PI*percent + randomRayOffset;
        float c, s;
        sincos(angle, c, s);
        float2 dirI = float2(c, s);
        float2 rayDir = normalize(mul(worldDirectionToBufferDirection, float4(dirI, 0, 0))).xy;//Dir in buffer space
        float2 rayOrigin = mul(worldToWallBuffer, float4(rayOriginWS, 0, 1)).xy;
        //do raycast
        RaycastResult result = raycast(rayOrigin, rayDir);

        float4 combined = 0;
        if(result.hit)
        {
            PixelGroup pixelGroup;
            pixelGroup.BL = result.endPosition;
            pixelGroup.BR = result.endPosition + uint2(1,0);
            pixelGroup.TL = result.endPosition + uint2(0,1);
            pixelGroup.TR = result.endPosition + uint2(1,1);
            float2 normal = get2DNormal(pixelGroup);
            float2 wsEndPos = result.endPosition.xy / pixelsPerUnit + _ProbeAreaOrigin;
            float2 localPos = (wsEndPos - probeStartPosition)/ probeSeparation;
            
            uint2 BLProbe = (uint2)(localPos);
            
            float2 f = frac(localPos);
            float4 BL = sampleIrradianceDirection(normal, BLProbe);
            float4 BR = sampleIrradianceDirection(normal, BLProbe + uint2(1,0));
            float4 TL = sampleIrradianceDirection(normal, BLProbe + uint2(0,1));
            float4 TR = sampleIrradianceDirection(normal, BLProbe + uint2(1,1));
            float4 bottom = lerp(BL, BR, f.x);
            float4 top = lerp(TL, TR, f.x);
            combined = lerp(bottom, top, f.y) * 4;//fix with depth later
        }
        
        
        float3 col = result.color + combined.rgb;
        
        
        for(int j = 0; j < directionCount; j++)
        {
            float percentJ = float(j)/float(directionCount);
            float2 dirJ = float2(cos(2*PI*percentJ), sin(2*PI*percentJ));
            directionColors[j] += col * max(0, dot(dirI, dirJ)) * denominator;
        }
    }
   
    float4 sum = 0;
    for(uint k = 0; k < uint(directionCount); k++)
    {
        uint2 offset = rowStartPos + uint2(gutterSize + k, 0);
        float4 col = float4(lerp(IrradianceBuffer[offset].xyz, directionColors[k], HYSTERESIS), 1);
        IrradianceBuffer[offset] = col;
        sum += col;
    }
    AverageIrradianceBuffer[id.xy] = sum / float(directionCount);
}

#pragma kernel FillGutter
[numthreads(64,1,1)]
void FillGutter (uint3 groupID : SV_GroupID, 
   uint3 groupThreadID : SV_GroupThreadID, 
   uint groupIndex : SV_GroupIndex, 
   uint3 id : SV_DispatchThreadID) 
{
    uint2 rowStartPos = id.xy * uint2(directionCount + gutterSize * 2, 1);
    uint2 gutterSpotOne = rowStartPos;
    uint2 gutterSpotTwo = rowStartPos + uint2(gutterSize + directionCount, 0);
    IrradianceBuffer[gutterSpotOne] = IrradianceBuffer[gutterSpotTwo - uint2(1,0)];
    IrradianceBuffer[gutterSpotTwo] = IrradianceBuffer[gutterSpotOne + uint2(1,0)];
}