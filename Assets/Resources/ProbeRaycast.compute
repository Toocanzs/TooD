Texture2D<float4> WallBuffer;
RWTexture2D<float4> IrradianceBuffer;
RWTexture2D<float4> AverageIrradianceBuffer;
RWTexture2D<float4> SDF_Buffer;
float probeSeparation;
float2 probeStartPosition;//GetProbeAreaOrigin() + OriginOffset
int directionCount;
float maxRayLength;
uint2 wallBufferSize;
uint2 probeCount;
int gutterSize;
float2 _ProbeAreaOrigin;
float HYSTERESIS;
int pixelsPerUnit;
float randomRayOffset;

float4x4 worldToWallBuffer;
float4x4 worldDirectionToBufferDirection;

#define MAX_DIRECTION_COUNT 128
#define PI 3.14159



RWTexture2D<float4> ExteriorDistanceBuffer;//Maybe add interior later

#pragma kernel JFA_set_seed
[numthreads(64,1,1)]
void JFA_set_seed (uint3 groupID : SV_GroupID, 
   uint3 groupThreadID : SV_GroupThreadID, 
   uint groupIndex : SV_GroupIndex, 
   uint3 id : SV_DispatchThreadID) 
{
    float4 col = 0;
    
    float2 worldPos = float2(id.xy) / pixelsPerUnit + _ProbeAreaOrigin;
    if(WallBuffer[id.xy].a > 0)
    {
        col = float4(worldPos, 0, 1);
    }
    
    ExteriorDistanceBuffer[id.xy] = col;
}

RWTexture2D<float4> JFA_Source;
RWTexture2D<float4> JFA_Dest;
uint stepWidth;

#pragma kernel JFA_flood
[numthreads(64,1,1)]
void JFA_flood (uint3 groupID : SV_GroupID, 
uint3 groupThreadID : SV_GroupThreadID, 
uint groupIndex : SV_GroupIndex, 
uint3 id : SV_DispatchThreadID) 
{
    float2 worldPos = float2(id.xy) / pixelsPerUnit + _ProbeAreaOrigin;
    float bestDistance = 9999;
    float4 bestCoordinate = 0;
    for(int y = -1; y <= 1; y++)
    {
        for(int x = -1; x <= 1; x ++)
        {
            uint2 sample = id.xy + uint2(x,y) * stepWidth;
            if(any(bool4(sample < 0, sample > wallBufferSize)))
                continue;
            float4 data = JFA_Source[sample];
            if(data.a < 1)//Invalid data
                continue;
            float currentDistance = distance(data.xy, worldPos);
            if(currentDistance < bestDistance)
            {
                bestDistance = currentDistance;
                bestCoordinate = float4(data.xy, 0, 1);
            }
        }
    }
    
    JFA_Dest[id.xy] = bestCoordinate;
}
 
 #pragma kernel JFA_dist
[numthreads(64,1,1)]
void JFA_dist (uint3 groupID : SV_GroupID, 
   uint3 groupThreadID : SV_GroupThreadID, 
   uint groupIndex : SV_GroupIndex, 
   uint3 id : SV_DispatchThreadID) 
{
    float2 worldPos = float2(id.xy) / pixelsPerUnit + _ProbeAreaOrigin;
    float4 data = JFA_Source[id.xy];
    float d = distance(data.xy, worldPos);
    JFA_Dest[id.xy] = float4(d,d,d,1);
}

struct PixelResults
{
    bool hit;
    float3 color;
    bool outOfBounds;
};

PixelResults testPixel(float2 pos) 
{
    uint2 p = uint2(pos);
    PixelResults o = (PixelResults)0;
    if(any(bool4(pos.xy < 0, pos.xy >= float2(wallBufferSize)))) //TODO: maybe move this out?
    {
        o.outOfBounds = true;
    }
    else
    {
        float4 color = WallBuffer[pos];
        if(color.a > 0)
        {
            o.hit = true;
            o.color = color.rgb;
        }
    }
    return o;
}
struct RaycastResult
{
    float3 color;
    float2 endPosition;
};

RaycastResult raycast(float2 start, float2 end) 
{
    RaycastResult result;
    result.color = 0;
    result.endPosition = start;
    float w = end.x - start.x;
    float h = end.y - start.y;
    
    float2 d1 = float2(sign(w),sign(h));

    float2 d2 = float2(sign(w),0);

    float longest = abs(w);
    float shortest = abs(h);
    if (longest <= shortest) 
    {
        longest = abs(h);
        shortest = abs(w);
        d2.y = sign(h);
        d2.x = 0;
    }
    float numerator = longest / 2.;
    for (int i = 0; i <= int(ceil(longest)); i++) 
    {
        PixelResults o = testPixel(start);
        if(o.outOfBounds)
        {
            return result;
        }
        if(o.hit)
        {
            result.color = o.color;
            return result;
        }
        numerator += shortest - (numerator >= longest ? longest : 0);
        start += numerator >= longest ? d1 : d2;
        result.endPosition = start;//Move after if hit so we get the last end position not inside the wall
    }
    return result;
}

float4 GetFromBufferClamped(uint2 pos)
{
    float4 col = AverageIrradianceBuffer[pos];
    if(any(bool4(pos > probeCount, pos < 0)))
    {
        //return float4(0,0,0,1);
    }
    return col;
}

struct PixelGroup
{
    uint2 BL;
    uint2 BR;
    uint2 TL;
    uint2 TR;
};

float map(PixelGroup pixels, float2 p)
{
    float bottom = lerp(SDF_Buffer[pixels.BL].x, SDF_Buffer[pixels.BR].x, p.x);
    float top = lerp(SDF_Buffer[pixels.TL].x, SDF_Buffer[pixels.TR].x, p.x);
    return lerp(bottom, top, p.y);
}

float2 get2DNormal(PixelGroup pixels) 
{
    float EPSILON = 0.25;
    return normalize(float2(
        map(pixels, float2(EPSILON, 0)) - map(pixels, float2(-EPSILON, 0)),
        map(pixels, float2(0, EPSILON)) - map(pixels, float2(0, -EPSILON))
    ));
}

float4 sampleIrradianceDirection(float2 normal, uint2 probe)
{
    float angle = atan2(normal.y, normal.x);
    int directionIndex = (angle /(2*PI))*directionCount;
    uint2 st = (probe) * uint2(directionCount + gutterSize * 2, 1);
    uint2 directionUV = st + uint2(gutterSize + directionIndex, 0);
    //TODO: needs to get rid of data that is inside walls or not visible from the probe?
    return IrradianceBuffer[directionUV];
}

#pragma kernel GenerateProbeData
[numthreads(64,1,1)]
void GenerateProbeData (uint3 groupID : SV_GroupID, 
   uint3 groupThreadID : SV_GroupThreadID, 
   uint groupIndex : SV_GroupIndex, 
   uint3 id : SV_DispatchThreadID) 
{
    float2 rayOriginWS = probeStartPosition + float2(id.xy) * probeSeparation;
    float3 directionColors[MAX_DIRECTION_COUNT];
    uint2 rowStartPos = id.xy * uint2(directionCount + gutterSize * 2, 1);
    
    for(int l = 0; l < directionCount; l++)
    {
        directionColors[l] = 0;//May or may not need to initialize
    }
    
    float denominator = (0.5/directionCount);
    //only half the rays contribute to a particular direction, so average acoss all those is sum/directionCount/2
    for(int i = 0; i < directionCount; i++)
    {
        float percent = float(i)/float(directionCount);
        float angle = 2*PI*percent + randomRayOffset;
        float c, s;
        sincos(angle, c, s);
        float2 dirI = float2(c, s);
        float2 rayDir = normalize(mul(worldDirectionToBufferDirection, float4(dirI, 0, 0))).xy;//Dir in buffer space
        float2 rayOrigin = mul(worldToWallBuffer, float4(rayOriginWS, 0, 1)).xy;
        float2 rayEndPos = rayOrigin + rayDir * maxRayLength;
        //do raycast
        RaycastResult result = raycast(rayOrigin, rayEndPos);

        //TODO: if result actually hit something
        PixelGroup pixelGroup;
        pixelGroup.BL = result.endPosition;
        pixelGroup.BR = result.endPosition + uint2(1,0);
        pixelGroup.TL = result.endPosition + uint2(0,1);
        pixelGroup.TR = result.endPosition + uint2(1,1);
        float2 normal = get2DNormal(pixelGroup);
        float2 wsEndPos = result.endPosition.xy / pixelsPerUnit + _ProbeAreaOrigin;
        float2 localPos = (wsEndPos - probeStartPosition)/ probeSeparation;
        
        uint2 BLProbe = (uint2)(localPos);
        
        float2 f = frac(localPos);
        float4 BL = sampleIrradianceDirection(normal, BLProbe);
        float4 BR = sampleIrradianceDirection(normal, BLProbe + uint2(1,0));
        float4 TL = sampleIrradianceDirection(normal, BLProbe + uint2(0,1));
        float4 TR = sampleIrradianceDirection(normal, BLProbe + uint2(1,1));
        //float4 bottom = lerp(BL, BR, f.x);
        //float4 top = lerp(TL, TR, f.x);
        float4 combined = BL + BR + TL + TR;
        
        
        float3 col = result.color + combined.rgb;
        
        
        for(int j = 0; j < directionCount; j++)
        {
            float percentJ = float(j)/float(directionCount);
            float2 dirJ = float2(cos(2*PI*percentJ), sin(2*PI*percentJ));
            directionColors[j] += col * max(0, dot(dirI, dirJ)) * denominator;
        }
    }
   
    float4 sum = 0;
    for(uint k = 0; k < uint(directionCount); k++)
    {
        uint2 offset = rowStartPos + uint2(gutterSize + k, 0);
        //TODO: When we add random directions IrradianceBuffer[offset] needs to be sampled with that random value
        //Also maybe the set needs to be 
        //But also maybe none of that is the case. Look at it first
        //Could also do the lerp at the average level, but then bounces will be more sparse(?)
        float4 col = float4(lerp(IrradianceBuffer[offset].xyz, directionColors[k], HYSTERESIS), 1);
        IrradianceBuffer[offset] = col;
        sum += col;
    }
    AverageIrradianceBuffer[id.xy] = sum / float(directionCount);
}

#pragma kernel FillGutter
[numthreads(64,1,1)]
void FillGutter (uint3 groupID : SV_GroupID, 
   uint3 groupThreadID : SV_GroupThreadID, 
   uint groupIndex : SV_GroupIndex, 
   uint3 id : SV_DispatchThreadID) 
{
    uint2 rowStartPos = id.xy * uint2(directionCount + gutterSize * 2, 1);
    uint2 gutterSpotOne = rowStartPos;
    uint2 gutterSpotTwo = rowStartPos + uint2(gutterSize + directionCount, 0);
    IrradianceBuffer[gutterSpotOne] = IrradianceBuffer[gutterSpotTwo - uint2(1,0)];
    IrradianceBuffer[gutterSpotTwo] = IrradianceBuffer[gutterSpotOne + uint2(1,0)];
}